package comp_proy;
import java_cup.runtime.*;

class Parser;

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder(message + ": ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( info.toString() );
    
    System.out.println(m);
  }
:};

//----Terminales----
//-Palabras clave
terminal BREAK, CASE, DEFAULT, ELSE, IF, MAIN, NULL, RETURN, SWITCH, WHILE;
terminal TIPO_BOOL, TIPO_CHAR, TIPO_FLOAT, TIPO_INT, TIPO_STRING;

//-Entrada y salida estandar
terminal READ_INT, READ_FLOAT;
terminal PRINT;

//-Separadores
terminal PAREN_A, PAREN_C, CURS_A, CURS_C, CUAD_A, CUAD_C;
terminal HASHTAG, DOSPUNTOS, COMA;

//-Operadores
terminal IGUAL, MAS, MENOS, POR, DIV, POTENCIA, COMPLEMENTO;
terminal AND, OR, NOT;
terminal ESIGUAL, DIFERENTE, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
terminal MASMAS, MENOSMENOS;
terminal MENOS_UNARIO;

//-Literales
terminal LIT_ENTERO;
terminal LIT_FLOTANTE;
terminal LIT_BOOLEANO;
terminal LIT_CHAR;
terminal LIT_STRING;

//-Identificador
terminal IDENTIF;


//----No terminales----
//-Estructura del programa
non terminal inicio, programa, funcMain, bloqueCod;

//-Funciones
non terminal crearFuncion, crearParametro, crearParametros;
non terminal llamarFuncion, parametro, parametros;

//-Sentencias
non terminal sentencia;
non terminal crearVar, crearInt, crearFloat, crearBool, crearChar, crearString, crearArrayInt, crearArrayChar;
non terminal crearAsignVar, crearAsignInt, crearAsignFloat, crearAsignBool, crearAsignChar, crearAsignString;
non terminal asignVar;
non terminal asignElemArreg;
non terminal salidaEst;
non terminal sentenciaReturn;

//-Estructuras de control
non terminal estrucControl, condicion, if, while, switch;
non terminal casosInt, casosFloat, casosBool, casosChar, casosString, casoDefault;

//-Expresiones
non terminal expr;
non terminal exprBin, operadorBin, operandoBin;
non terminal exprUna, operadorUna, operandoUna;
non terminal exprRel, operadorRel, operandoRel;
non terminal exprLog, operadorLog, operandoLog;

//-Tipos y valores
non terminal tipoFun;
non terminal elemArreglo;
non terminal valorInt, valorFloat;
non terminal entradaEstInt, entradaEstFloat;

//----Precedencia----
precedence left OR;
precedence left AND;
precedence left ESIGUAL, DIFERENTE;
precedence left MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
precedence left MAS, MENOS;
precedence left POR, DIV, COMPLEMENTO;
precedence left POTENCIA;
precedence right NOT, MENOS_UNARIO;
precedence left CUAD_A, CUAD_C, PAREN_A, PAREN_C, MASMAS, MENOSMENOS;


//----Gramatica----
start with inicio;

//1		Estructura del programa
inicio ::= programa;
programa ::= funcMain
			| crearFuncion programa
;
funcMain ::= TIPO_INT MAIN PAREN_A PAREN_C CURS_A bloqueCod CURS_C
;
bloqueCod ::= sentencia
			| estrucControl
			| sentencia bloqueCod
			| estrucControl bloqueCod
;

//2		Funciones
//2.1	Definir funcion
crearFuncion ::= tipoFun IDENTIF PAREN_A PAREN_C CURS_A bloqueCod CURS_C
				| tipoFun IDENTIF PAREN_A crearParametros PAREN_C CURS_A bloqueCod CURS_C
;
crearParametro ::= TIPO_INT IDENTIF
				| TIPO_FLOAT IDENTIF
				| TIPO_BOOL IDENTIF
				| TIPO_CHAR IDENTIF
				| TIPO_STRING IDENTIF
				| TIPO_INT IDENTIF CUAD_A LIT_ENTERO CUAD_C
				| TIPO_CHAR IDENTIF CUAD_A LIT_ENTERO CUAD_C
;
crearParametros ::= crearParametro
				| crearParametro COMA crearParametros
;
//2.2	Llamar funcion
llamarFuncion ::= IDENTIF PAREN_A PAREN_C
				| IDENTIF PAREN_A parametros PAREN_C
;
parametro ::= valorInt
			| valorFloat
			| LIT_BOOLEANO
			| LIT_CHAR
			| LIT_STRING
			| IDENTIF
			| llamarFuncion
			| elemArreglo
			| expr
;
parametros ::= parametro
			| parametro COMA parametros
;


//3		Sentencias
sentencia ::= crearVar HASHTAG
			| crearAsignVar HASHTAG
			| asignVar HASHTAG
			| asignElemArreg HASHTAG
			| expr HASHTAG
			| llamarFuncion HASHTAG
			| salidaEst HASHTAG
			| BREAK HASHTAG
			| sentenciaReturn HASHTAG
			| error HASHTAG {: System.out.println("Error sem√°ntico en sentencia":}
;

//3.1	Crear variables
crearVar ::= crearInt
			| crearFloat
			| crearBool
			| crearChar
			| crearString
			| crearArrayInt
			| crearArrayChar
;
crearInt		::= TIPO_INT IDENTIF;
crearFloat		::= TIPO_FLOAT IDENTIF;
crearBool		::= TIPO_BOOL IDENTIF;
crearChar		::= TIPO_CHAR IDENTIF;
crearString		::= TIPO_STRING IDENTIF;
crearArrayInt	::= TIPO_INT IDENTIF CUAD_A LIT_ENTERO CUAD_C;
crearArrayChar	::= TIPO_CHAR IDENTIF CUAD_A LIT_ENTERO CUAD_C;

//3.2	Crear y asignar variables
crearAsignVar ::= crearAsignInt
				| crearAsignFloat
				| crearAsignBool
				| crearAsignChar
				| crearAsignString
;
crearAsignInt ::= crearInt IGUAL valorInt
				| crearInt IGUAL IDENTIF
				| crearInt IGUAL llamarFuncion
				| crearInt IGUAL elemArreglo
				| crearInt IGUAL exprBin
				| crearInt IGUAL exprUna
				| crearInt IGUAL NULL
;
crearAsignFloat ::= crearFloat IGUAL valorFloat
				| crearFloat IGUAL IDENTIF
				| crearFloat IGUAL llamarFuncion
				| crearFloat IGUAL exprBin
				| crearFloat IGUAL exprUna
				| crearFloat IGUAL NULL
;
crearAsignBool ::= crearBool IGUAL LIT_BOOLEANO
				| crearBool IGUAL IDENTIF
				| crearBool IGUAL exprRel
				| crearBool IGUAL exprLog
				| crearBool IGUAL NULL
;
crearAsignChar ::= crearChar IGUAL LIT_CHAR
				| crearChar IGUAL IDENTIF
				| crearChar IGUAL llamarFuncion
				| crearChar IGUAL elemArreglo
				| crearChar IGUAL NULL
;
crearAsignString ::= crearString IGUAL LIT_STRING
					| crearString IGUAL IDENTIF
					| crearString IGUAL NULL
;

//3.3	Asignar variables
asignVar ::= IDENTIF IGUAL valorInt
			| IDENTIF IGUAL valorFloat
			| IDENTIF IGUAL LIT_BOOLEANO
			| IDENTIF IGUAL LIT_CHAR
			| IDENTIF IGUAL LIT_STRING
			| IDENTIF IGUAL IDENTIF
			| IDENTIF IGUAL llamarFuncion
			| IDENTIF IGUAL elemArreglo
			| IDENTIF IGUAL expr
			| IDENTIF IGUAL NULL
;		

asignElemArreg ::= elemArreglo IGUAL valorInt
				| elemArreglo IGUAL exprBin
				| elemArreglo IGUAL exprUna
				| elemArreglo IGUAL LIT_CHAR
				| elemArreglo IGUAL IDENTIF
				| elemArreglo IGUAL llamarFuncion
				| elemArreglo IGUAL elemArreglo
				| elemArreglo IGUAL NULL
;

//3.4	Salida estandar
salidaEst ::= PRINT PAREN_A valorInt PAREN_C
			| PRINT PAREN_A valorFloat PAREN_C
			| PRINT PAREN_A LIT_CHAR PAREN_C
			| PRINT PAREN_A LIT_STRING PAREN_C
			| PRINT PAREN_A IDENTIF PAREN_C
			| PRINT PAREN_A llamarFuncion PAREN_C
			| PRINT PAREN_A elemArreglo PAREN_C
			| PRINT PAREN_A exprBin PAREN_C
			| PRINT PAREN_A exprUna PAREN_C
;

//3.5	Return
sentenciaReturn ::= RETURN valorInt HASHTAG
				| RETURN valorFloat HASHTAG
				| RETURN LIT_CHAR HASHTAG
				| RETURN IDENTIF HASHTAG
				| RETURN llamarFuncion HASHTAG
				| RETURN elemArreglo HASHTAG
				| RETURN exprBin HASHTAG
				| RETURN exprUna HASHTAG
;

//4		Estructuras de control
estrucControl ::= if
				| while
				| switch
;
condicion ::= LIT_BOOLEANO
			| IDENTIF
			| exprRel
			| exprLog
;

//4.1	If
if ::= IF PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C
	| IF PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C ELSE CURS_A bloqueCod CURS_C
;

//4.2	While
while ::= WHILE PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C;

//4.3	Switch
switch ::= SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosInt casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosFloat casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosBool casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosChar casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosString casoDefault CURS_C
;

casosInt ::= CASE LIT_ENTERO DOSPUNTOS bloqueCod
			| CASE LIT_ENTERO DOSPUNTOS bloqueCod casosInt
;
casosFloat ::= CASE LIT_FLOTANTE DOSPUNTOS bloqueCod
			| CASE LIT_FLOTANTE DOSPUNTOS bloqueCod casosFloat
;
casosBool ::= CASE LIT_BOOLEANO DOSPUNTOS bloqueCod
			| CASE LIT_BOOLEANO DOSPUNTOS bloqueCod casosBool
;
casosChar ::= CASE LIT_CHAR DOSPUNTOS bloqueCod
			| CASE LIT_CHAR DOSPUNTOS bloqueCod casosChar
;
casosString ::= CASE LIT_STRING DOSPUNTOS bloqueCod
			| CASE LIT_STRING DOSPUNTOS bloqueCod casosString
;

casoDefault ::= DEFAULT CURS_A bloqueCod CURS_C;


//5		Expresiones
expr ::= exprBin
		| exprUna
		| exprRel
		| exprLog
;

//5.1	Expresiones arit binarias
exprBin ::= operandoBin operadorBin operandoBin;

operadorBin ::= MAS
			| MENOS
			| DIV
			| POR
			| COMPLEMENTO
			| POTENCIA
;
operandoBin ::= valorInt
			| valorFloat
			| IDENTIF
			| llamarFuncion
			| elemArreglo
			| exprBin 
			| exprUna
			| PAREN_A exprBin PAREN_C
;

//5.2	Expresiones arit unarias
exprUna ::= operandoUna operadorUna
		| MENOS operandoUna
		%prec MENOS_UNARIO
		| MENOS valorFloat
		%prec MENOS_UNARIO
;
operadorUna ::= MENOSMENOS
			| MASMAS
;
operandoUna ::= valorInt
			| IDENTIF
			| llamarFuncion
			| elemArreglo
			| PAREN_A exprBin PAREN_C
;

//5.3	Expresiones relacionales
exprRel ::= operandoRel operadorRel operandoRel
			| operandoRel operadorRel operandoLog
			| operandoLog operadorRel operandoRel
			| operandoLog operadorRel operandoLog
;
operadorRel ::= MAYOR
			| MENOR
			| MAYORIGUAL
			| MENORIGUAL
			| ESIGUAL
			| DIFERENTE
;
operandoRel ::= valorInt
			| valorFloat
			| llamarFuncion
			| elemArreglo
			| PAREN_A exprBin PAREN_C
			| exprUna
			| NULL
;

//5.4	Expresiones logicas
exprLog ::= operandoLog operadorLog operandoLog
		| NOT LIT_BOOLEANO
		| NOT IDENTIF
		| NOT PAREN_A exprRel PAREN_C
		| NOT PAREN_A exprLog PAREN_C
;
operadorLog ::= AND
			| OR
;
operandoLog ::= LIT_BOOLEANO
			| IDENTIF
			| exprRel
			| exprLog
			| PAREN_A exprRel PAREN_C
			| PAREN_A exprLog PAREN_C
;

//6		Tipos y valores
tipoFun ::= TIPO_INT
		| TIPO_FLOAT
		| TIPO_CHAR
;
elemArreglo ::= IDENTIF CUAD_A LIT_ENTERO CUAD_C
;

valorInt ::=  LIT_ENTERO
			| entradaEstInt
;
entradaEstInt ::= READ_INT PAREN_A PAREN_C
;

valorFloat ::= LIT_FLOTANTE
			| entradaEstFloat
;
entradaEstFloat ::= READ_FLOAT PAREN_A PAREN_C
;
