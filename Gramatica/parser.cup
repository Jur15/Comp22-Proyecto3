package comp_proy;
import java_cup.runtime.*;

class Parser;

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder(message + ": ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( info.toString() );
    
    System.out.println(m);
  }
:};

//----Terminales----
//-Palabras clave
terminal BREAK, CASE, DEFAULT, ELSE, IF, MAIN, NULL, RETURN, SWITCH, WHILE;
terminal TIPO_BOOL, TIPO_CHAR, TIPO_FLOAT, TIPO_INT, TIPO_STRING;

//-Entrada y salida estandar
terminal READ_INT, READ_FLOAT;
terminal PRINT_INT, PRINT_FLOAT, PRINT_CHAR, PRINT_STRING;

//-Separadores
terminal PAREN_A, PAREN_C, CURS_A, CURS_C, CUAD_A, CUAD_C;
terminal HASHTAG, DOSPUNTOS, COMA;

//-Operadores
terminal IGUAL, MAS, MENOS, POR, DIV, POTENCIA, COMPLEMENTO;
terminal AND, OR, NOT;
terminal ESIGUAL, DIFERENTE, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
terminal MASMAS, MENOSMENOS;
terminal MENOS_UNARIO;

//-Literales
terminal LIT_ENTERO;
terminal LIT_FLOTANTE;
terminal LIT_BOOLEANO;
terminal LIT_CHAR;
terminal LIT_STRING;

//-Identificador
terminal IDENTIF;


//----No terminales----
//-Estructura del programa
non terminal inicio, programa, funcMain, bloqueCod;

//-Funciones
non terminal crearFuncion, crearParametros, funcReturn;
non terminal llamarFuncion, parametros;

//-Sentencias
non terminal sentencia;
non terminal crearVar, crearInt, crearFloat, crearBool, crearChar, crearString, crearArrayInt, crearArrayChar;
non terminal crearAsignVar, crearAsignInt, crearAsignFloat, crearAsignBool, crearAsignChar, crearAsignString;
non terminal asignVar;
non terminal asignElemArreg;
non terminal salidaEst;
non terminal sentenciaBreak;

//-Estructuras de control
non terminal estrucControl, condicion, if, while, switch;
non terminal casosInt, casosFloat, casosBool, casosChar, casosString, casoDefault;

//-Expresiones
non terminal expr;
non terminal exprBin, operadorBin, operandoBin;
non terminal exprUna, operadorUna, operandoUna;
non terminal exprRel, operadorRel, operadorIgual, operandoRel;
non terminal exprLog, operadorLog, operandoLog;

//-Tipos y valores
non terminal tipoFun, tipoVar;
non terminal elemArreglo;
non terminal valorInt, valorFloat, valorBool, valorChar, valorString;
non terminal entradaEstInt, entradaEstFloat;

//----Precedencia----
precedence left OR;
precedence left AND;
precedence left ESIGUAL, DIFERENTE;
precedence left MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
precedence left MAS, MENOS;
precedence left POR, DIV, COMPLEMENTO;
precedence left POTENCIA;
precedence right NOT, MENOS_UNARIO;
precedence left CUAD_A, CUAD_C, PAREN_A, PAREN_C, MASMAS, MENOSMENOS;


//----Gramatica----
start with inicio;

//1		Estructura del programa
inicio ::= programa;
programa ::= funcMain
			| programa crearFuncion
			| crearFuncion programa
;
funcMain ::= TIPO_INT MAIN PAREN_A PAREN_C CURS_A bloqueCod funcReturn CURS_C
;
bloqueCod ::= sentencia
			| estrucControl
			| sentencia bloqueCod
			| estrucControl bloqueCod
;

//2		Funciones
//2.1	Definir funcion
crearFuncion ::= tipoFun IDENTIF PAREN_A PAREN_C CURS_A bloqueCod funcReturn CURS_C
				| tipoFun IDENTIF PAREN_A crearParametros PAREN_C CURS_A bloqueCod funcReturn CURS_C
;
crearParametros ::= tipoVar IDENTIF
				| TIPO_INT IDENTIF CUAD_A LIT_ENTERO CUAD_C
				| TIPO_CHAR IDENTIF CUAD_A LIT_ENTERO CUAD_C
				| tipoVar IDENTIF COMA crearParametros
				| TIPO_INT IDENTIF CUAD_A LIT_ENTERO CUAD_C COMA crearParametros
				| TIPO_CHAR IDENTIF CUAD_A LIT_ENTERO CUAD_C COMA crearParametros
;
funcReturn ::= RETURN valorInt HASHTAG
			| RETURN valorFloat HASHTAG
			| RETURN valorChar HASHTAG
			| RETURN exprBin HASHTAG
			| RETURN exprUna HASHTAG
;
//2.2	Llamar funcion
llamarFuncion ::= IDENTIF PAREN_A PAREN_C
				| IDENTIF PAREN_A parametros PAREN_C
;
parametros ::= valorInt
			| valorFloat
			| valorBool
			| valorChar
			| valorString
			| expr
			| valorInt COMA parametros
			| valorFloat COMA parametros
			| valorBool COMA parametros
			| valorChar COMA parametros
			| valorString COMA parametros
			| expr COMA parametros
;

//3		Sentencias
sentencia ::= crearVar HASHTAG
			| crearAsignVar HASHTAG
			| asignVar HASHTAG
			| asignElemArreg HASHTAG
			| expr HASHTAG
			| llamarFuncion HASHTAG
			| salidaEst HASHTAG
			| sentenciaBreak
;

//3.1	Crear variables
crearVar ::= crearInt
			| crearFloat
			| crearBool
			| crearChar
			| crearString
			| crearArrayInt
			| crearArrayChar
;
crearInt		::= TIPO_INT IDENTIF;
crearFloat		::= TIPO_FLOAT IDENTIF;
crearBool		::= TIPO_BOOL IDENTIF;
crearChar		::= TIPO_CHAR IDENTIF;
crearString		::= TIPO_STRING IDENTIF;
crearArrayInt	::= TIPO_INT IDENTIF CUAD_A LIT_ENTERO CUAD_C;
crearArrayChar	::= TIPO_CHAR IDENTIF CUAD_A LIT_ENTERO CUAD_C;

//3.2	Crear y asignar variables
crearAsignVar ::= crearAsignInt
				| crearAsignFloat
				| crearAsignBool
				| crearAsignChar
				| crearAsignString
;

crearAsignInt		::= crearInt IGUAL valorInt
					| crearInt IGUAL exprBin
					| crearInt IGUAL exprUna
;
crearAsignFloat		::= crearFloat IGUAL valorFloat
					| crearFloat IGUAL exprBin
					| crearFloat IGUAL exprUna
;
crearAsignBool		::= crearBool IGUAL valorBool
					| crearBool IGUAL exprRel
					| crearBool IGUAL exprLog
;
crearAsignChar		::= crearChar IGUAL valorChar;
crearAsignString	::= crearString IGUAL valorString;

//3.3	Asignar variables
asignVar ::= IDENTIF IGUAL valorInt
			| IDENTIF IGUAL valorFloat
			| IDENTIF IGUAL valorBool
			| IDENTIF IGUAL valorChar
			| IDENTIF IGUAL valorString
			| IDENTIF IGUAL expr
;		

asignElemArreg ::= elemArreglo IGUAL valorInt
				| elemArreglo IGUAL exprBin
				| elemArreglo IGUAL exprUna
				| elemArreglo IGUAL valorChar
;

//3.4	Salida estandar
salidaEst ::= PRINT_INT PAREN_A valorInt PAREN_C
			| PRINT_FLOAT PAREN_A valorFloat PAREN_C
			| PRINT_CHAR PAREN_A valorChar PAREN_C
			| PRINT_STRING PAREN_A valorString PAREN_C
;

//3.5	Break
sentenciaBreak ::= BREAK HASHTAG
;


//4		Estructuras de control
estrucControl ::= if
				| while
				| switch
;
condicion ::= valorBool
			| exprRel
			| exprLog
;

//4.1	If
if ::= IF PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C
	| IF PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C ELSE CURS_A bloqueCod CURS_C
;

//4.2	While
while ::= WHILE PAREN_A condicion PAREN_C CURS_A bloqueCod CURS_C;

//4.3	Switch
switch ::= SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosInt casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosFloat casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosBool casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosChar casoDefault CURS_C
		| SWITCH PAREN_A IDENTIF PAREN_C CURS_A casosString casoDefault CURS_C
;

casosInt ::= CASE LIT_ENTERO DOSPUNTOS bloqueCod
			| CASE LIT_ENTERO DOSPUNTOS bloqueCod casosInt
;
casosFloat ::= CASE LIT_FLOTANTE DOSPUNTOS bloqueCod
			| CASE LIT_FLOTANTE DOSPUNTOS bloqueCod casosFloat
;
casosBool ::= CASE LIT_BOOLEANO DOSPUNTOS bloqueCod
			| CASE LIT_BOOLEANO DOSPUNTOS bloqueCod casosBool
;
casosChar ::= CASE LIT_CHAR DOSPUNTOS bloqueCod
			| CASE LIT_CHAR DOSPUNTOS bloqueCod casosChar
;
casosString ::= CASE LIT_STRING DOSPUNTOS bloqueCod
			| CASE LIT_STRING DOSPUNTOS bloqueCod casosString
;

casoDefault ::= DEFAULT CURS_A bloqueCod CURS_C;


//5		Expresiones
expr ::= exprBin
		| exprUna
		| exprRel
		| exprLog
;

//5.1	Expresiones arit binarias
exprBin ::= operandoBin operadorBin operandoBin;

operadorBin ::= MAS
			| MENOS
			| DIV
			| POR
			| COMPLEMENTO
			| POTENCIA
;
operandoBin ::= valorInt
			| valorFloat
			| exprBin 
			| exprUna
			| PAREN_A exprBin PAREN_C
;

//5.2	Expresiones arit unarias
exprUna ::= operandoUna operadorUna
		| MENOS operandoUna
		%prec MENOS_UNARIO
		| MENOS valorFloat
		%prec MENOS_UNARIO
;
operadorUna ::= MENOSMENOS
			| MASMAS
;
operandoUna ::= valorInt
			| PAREN_A exprBin PAREN_C
;

//5.3	Expresiones relacionales
exprRel ::= operandoRel operadorRel operandoRel
		| operandoRel operadorIgual operandoRel
		| operandoLog operadorIgual operandoLog
;
operadorRel ::= MAYOR
			| MENOR
			| MAYORIGUAL
			| MENORIGUAL
;
operadorIgual ::= ESIGUAL
				| DIFERENTE
;
operandoRel ::= valorInt
			| valorFloat
			| PAREN_A exprBin PAREN_C
			| exprUna
;

//5.4	Expresiones logicas
exprLog ::= operandoLog operadorLog operandoLog
		| NOT valorBool
		| NOT PAREN_A exprRel PAREN_C
		| NOT PAREN_A exprLog PAREN_C
;
operadorLog ::= AND
			| OR
;
operandoLog ::= valorBool
			| exprRel
			| exprLog
			| PAREN_A exprRel PAREN_C
			| PAREN_A exprLog PAREN_C
;

//6		Tipos y valores
tipoFun ::= TIPO_INT
		| TIPO_FLOAT
		| TIPO_CHAR
;
tipoVar ::= TIPO_INT
		| TIPO_FLOAT
		| TIPO_BOOL
		| TIPO_CHAR
		| TIPO_STRING
;
elemArreglo ::= IDENTIF CUAD_A LIT_ENTERO CUAD_C
;

valorInt ::=  LIT_ENTERO
			| IDENTIF
			| llamarFuncion
			| entradaEstInt
			| elemArreglo
;
entradaEstInt ::= READ_INT PAREN_A PAREN_C
;
valorFloat ::= LIT_FLOTANTE
			| IDENTIF
			| llamarFuncion
			| entradaEstFloat
;
entradaEstFloat ::= READ_FLOAT PAREN_A PAREN_C
;
valorBool ::= LIT_BOOLEANO
			| IDENTIF
;
valorChar ::= LIT_CHAR
			| IDENTIF
			| llamarFuncion
			| elemArreglo
;
valorString ::= LIT_STRING
			| IDENTIF
;